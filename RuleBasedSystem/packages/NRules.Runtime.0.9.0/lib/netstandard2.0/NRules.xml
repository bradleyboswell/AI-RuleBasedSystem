<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NRules</name>
    </assembly>
    <members>
        <member name="T:NRules.Activation">
            <summary>
            Represents a match of all rule's conditions.
            </summary>
            <seealso cref="T:NRules.RuleModel.IMatch"/>
            <seealso cref="T:NRules.RuleModel.IFactMatch"/>
        </member>
        <member name="P:NRules.Activation.Rule">
            <summary>
            Rule that got activated.
            </summary>
        </member>
        <member name="P:NRules.Activation.Facts">
            <summary>
            Facts matched by the rule.
            </summary>
        </member>
        <member name="P:NRules.Activation.Trigger">
            <summary>
            Event that triggered the match.
            </summary>
        </member>
        <member name="T:NRules.IAgenda">
            <summary>
            Agenda stores matches between rules and facts. These matches are called activations.
            Multiple activations are ordered according to the conflict resolution strategy.
            </summary>
            <seealso cref="T:NRules.RuleModel.IMatch"/>
            <seealso cref="T:NRules.AgendaFilters.IAgendaFilter"/>
        </member>
        <member name="P:NRules.IAgenda.IsEmpty">
            <summary>
            Indicates whether there are any activations in the agenda.
            </summary>
            <value>If agenda is empty then <c>true</c> otherwise <c>false</c>.</value>
        </member>
        <member name="M:NRules.IAgenda.Peek">
            <summary>
            Retrieves the next match, without removing it from agenda.
            </summary>
            <remarks>Throws <c>InvalidOperationException</c> if agenda is empty.</remarks>
            <returns>Next match.</returns>
        </member>
        <member name="M:NRules.IAgenda.Clear">
            <summary>
            Removes all matches from agenda.
            </summary>
        </member>
        <member name="M:NRules.IAgenda.AddFilter(NRules.AgendaFilters.IAgendaFilter)">
            <summary>
            Adds a global filter to the agenda.
            </summary>
            <param name="filter">Filter to be applied to all activations before they are placed on the agenda.</param>
        </member>
        <member name="M:NRules.IAgenda.AddFilter(NRules.RuleModel.IRuleDefinition,NRules.AgendaFilters.IAgendaFilter)">
            <summary>
            Adds a rule-level filter to the agenda.
            </summary>
            <param name="rule">Rule, whose activations are to be filtered before placing them on the agenda.</param>
            <param name="filter">Filter to be applied to all activations for a given rule before they are placed on the agenda.</param>
        </member>
        <member name="T:NRules.AgendaExpressionEvaluationException">
            <summary>
            Represents errors that occur while evaluating agenda expression.
            </summary>
        </member>
        <member name="P:NRules.AgendaExpressionEvaluationException.RuleName">
            <summary>
            Rule that caused exception.
            </summary>
        </member>
        <member name="T:NRules.AgendaFilters.AgendaContext">
            <summary>
            Context associated with the agenda operation.
            </summary>
        </member>
        <member name="T:NRules.AgendaFilters.IAgendaFilter">
            <summary>
            Base interface for agenda filters.
            Agenda filters are applied to rule matches (activations) before they are added to the agenda.
            If activation does not pass all the filters, it is not added to the agenda, and so the rule will not fire.
            </summary>
        </member>
        <member name="M:NRules.AgendaFilters.IAgendaFilter.Accept(NRules.AgendaFilters.AgendaContext,NRules.Activation)">
            <summary>
            Tests rule activation whether it should be added to the agenda.
            </summary>
            <param name="context">Agenda context.</param>
            <param name="activation">Rule activation.</param>
            <returns>Whether the activation should be added to the agenda - <c>true</c>, or not - <c>false</c>.</returns>
        </member>
        <member name="T:NRules.Aggregators.IAggregateExpression">
            <summary>
            Expression used by an aggregator, compiled to an executable form.
            </summary>
        </member>
        <member name="P:NRules.Aggregators.IAggregateExpression.Name">
            <summary>
            Name of the aggregate expression.
            </summary>
        </member>
        <member name="M:NRules.Aggregators.IAggregateExpression.Invoke(NRules.Aggregators.AggregationContext,NRules.RuleModel.ITuple,NRules.RuleModel.IFact)">
            <summary>
            Invokes the expression with the given inputs.
            </summary>
            <param name="context">Aggregation context.</param>
            <param name="tuple">Partial match up to the aggregate element.</param>
            <param name="fact">Fact being processed by the aggregate element.</param>
            <returns>Result of the expression.</returns>
        </member>
        <member name="T:NRules.Aggregators.AggregateExpressionExtensions">
            <summary>
            Extension methods used for working with collections of aggregate expressions.
            </summary>
        </member>
        <member name="M:NRules.Aggregators.AggregateExpressionExtensions.Find(System.Collections.Generic.IEnumerable{NRules.Aggregators.IAggregateExpression},System.String)">
            <summary>
            Get an enumerable of matching aggregate expressions.
            </summary>
            <param name="expressions">The list of aggregate expressions to search through.</param>
            <param name="name">Name of the aggregate expressions to find.</param>
            <returns></returns>
        </member>
        <member name="M:NRules.Aggregators.AggregateExpressionExtensions.FindSingle(System.Collections.Generic.IEnumerable{NRules.Aggregators.IAggregateExpression},System.String)">
            <summary>
            Get a single matching aggregate expression.
            </summary>
            <param name="expressions">The list of aggregate expressions to search through.</param>
            <param name="name">Name of the aggregate expression to find.</param>
            <returns></returns>
        </member>
        <member name="T:NRules.Aggregators.AggregationContext">
            <summary>
            Context associated with the aggregation operation.
            </summary>
        </member>
        <member name="T:NRules.Aggregators.AggregationAction">
            <summary>
            Action that aggregation performed on the aggregate, based on added/modified/removed facts.
            </summary>
        </member>
        <member name="F:NRules.Aggregators.AggregationAction.None">
            <summary>
            No changes at the aggregate level.
            </summary>
        </member>
        <member name="F:NRules.Aggregators.AggregationAction.Added">
            <summary>
            New aggregate created.
            </summary>
        </member>
        <member name="F:NRules.Aggregators.AggregationAction.Modified">
            <summary>
            Existing aggregate modified.
            </summary>
        </member>
        <member name="F:NRules.Aggregators.AggregationAction.Removed">
            <summary>
            Existing aggregate removed.
            </summary>
        </member>
        <member name="T:NRules.Aggregators.AggregationResult">
            <summary>
            Result of the aggregation.
            </summary>
        </member>
        <member name="M:NRules.Aggregators.AggregationResult.None(System.Object,System.Collections.Generic.IEnumerable{NRules.RuleModel.IFact})">
            <summary>
            Constructs an aggregation result that indicates no changes at the aggregate level.
            </summary>
            <param name="result">Aggregate.</param>
            <param name="source">Aggregate source facts.</param>
            <returns>Aggregation result.</returns>
        </member>
        <member name="M:NRules.Aggregators.AggregationResult.Added(System.Object,System.Collections.Generic.IEnumerable{NRules.RuleModel.IFact})">
            <summary>
            Constructs an aggregation result that indicates a new aggregate.
            </summary>
            <param name="result">Aggregate.</param>
            <param name="source">Aggregate source facts.</param>
            <returns>Aggregation result.</returns>
        </member>
        <member name="M:NRules.Aggregators.AggregationResult.Modified(System.Object,System.Object,System.Collections.Generic.IEnumerable{NRules.RuleModel.IFact})">
            <summary>
            Constructs an aggregation result that indicates a modification at the aggregate level.
            </summary>
            <param name="result">Aggregate.</param>
            <param name="previous">Previous aggregate.</param>
            <param name="source">Aggregate source facts.</param>
            <returns>Aggregation result.</returns>
        </member>
        <member name="M:NRules.Aggregators.AggregationResult.Removed(System.Object)">
            <summary>
            Constructs an aggregation result that indicates an aggregate was removed.
            </summary>
            <param name="result">Aggregate.</param>
            <returns>Aggregation result.</returns>
        </member>
        <member name="P:NRules.Aggregators.AggregationResult.Action">
            <summary>
            Action that aggregation performed on the aggregate.
            </summary>
        </member>
        <member name="P:NRules.Aggregators.AggregationResult.Aggregate">
            <summary>
            Resulting aggregate.
            </summary>
        </member>
        <member name="P:NRules.Aggregators.AggregationResult.Previous">
            <summary>
            Previous aggregate.
            </summary>
        </member>
        <member name="P:NRules.Aggregators.AggregationResult.Source">
            <summary>
            Facts that produced this aggregation result.
            </summary>
        </member>
        <member name="T:NRules.Aggregators.AggregatorRegistry">
            <summary>
            Registry of custom aggregator factories.
            </summary>
        </member>
        <member name="P:NRules.Aggregators.AggregatorRegistry.Item(System.String)">
            <summary>
            Looks up custom aggregator factory type by the aggregator name.
            </summary>
            <param name="name">Name of the custom aggregator.</param>
            <returns>Custom aggregator type or <c>null</c> if a given aggregator type is not registered.</returns>
        </member>
        <member name="M:NRules.Aggregators.AggregatorRegistry.RegisterFactory(System.String,System.Type)">
            <summary>
            Registers a custom aggregator factory type, so that rules that use it can be successfully compiled.
            </summary>
            <param name="name">Name of the custom aggregator.</param>
            <param name="factoryType">Custom aggregator factory type.</param>
        </member>
        <member name="T:NRules.Aggregators.CollectionAggregator`1">
            <summary>
            Aggregate that folds matching facts into a collection.
            </summary>
            <typeparam name="TElement">Type of elements to collect.</typeparam>
        </member>
        <member name="T:NRules.Aggregators.CollectionAggregatorFactory">
            <summary>
            Aggregator factory for collection aggregator.
            Depending on supplied expressions this will create an ordered or an unordered fact aggregator.
            </summary>
        </member>
        <member name="T:NRules.Aggregators.DefaultKeyMap`2">
            <summary>
            Map (dictionary) that supports mapping using a default value for the key type 
            (which is <c>null</c> for reference types).
            </summary>
        </member>
        <member name="T:NRules.Aggregators.FlatteningAggregator`2">
            <summary>
            Aggregator that projects each matching fact into a collection and creates a new fact for each element in that collection.
            </summary>
            <typeparam name="TSource">Type of source element.</typeparam>
            <typeparam name="TResult">Type of result element.</typeparam>
        </member>
        <member name="T:NRules.Aggregators.FlatteningAggregatorFactory">
            <summary>
            Aggregator factory for flattening aggregator.
            </summary>
        </member>
        <member name="T:NRules.Aggregators.GroupByAggregator`3">
            <summary>
            Aggregator that groups matching facts into collections of elements with the same key.
            </summary>
            <typeparam name="TSource">Type of source elements to group.</typeparam>
            <typeparam name="TKey">Type of grouping key.</typeparam>
            <typeparam name="TElement">Type of elements to group.</typeparam>
        </member>
        <member name="T:NRules.Aggregators.GroupByAggregatorFactory">
            <summary>
            Aggregator factory for group by aggregator.
            </summary>
        </member>
        <member name="T:NRules.Aggregators.IAggregator">
            <summary>
            Base interface for fact aggregators.
            An aggregator is a stateful element of the rules engine, that receives matching facts of a particular kind,
            and can combine them into a synthetic fact, that is then used by the downstream logic in the rule.
            Aggregator also recieves updates and removals for the matching facts, so that it can keep the corresponding
            aggregate facts in sync.
            An aggregator must be supplemented by a corresponding implementation of <see cref="T:NRules.Aggregators.IAggregatorFactory"/> that
            knows how to create new instances of the aggregator.
            </summary>
        </member>
        <member name="M:NRules.Aggregators.IAggregator.Add(NRules.Aggregators.AggregationContext,NRules.RuleModel.ITuple,System.Collections.Generic.IEnumerable{NRules.RuleModel.IFact})">
            <summary>
            Called by the rules engine when new facts enter corresponding aggregator.
            </summary>
            <param name="context">Aggregation context.</param>
            <param name="tuple">Tuple containing preceding partial matches.</param>
            <param name="facts">New facts to add to the aggregate.</param>
            <returns>Results of the operation on the aggregate, based on the added facts.</returns>
        </member>
        <member name="M:NRules.Aggregators.IAggregator.Modify(NRules.Aggregators.AggregationContext,NRules.RuleModel.ITuple,System.Collections.Generic.IEnumerable{NRules.RuleModel.IFact})">
            <summary>
            Called by the rules engine when existing facts are modified in the corresponding aggregator.
            </summary>
            <param name="context">Aggregation context.</param>
            <param name="tuple">Tuple containing preceding partial matches.</param>
            <param name="facts">Existing facts to update in the aggregate.</param>
            <returns>Results of the operation on the aggregate, based on the modified facts.</returns>
        </member>
        <member name="M:NRules.Aggregators.IAggregator.Remove(NRules.Aggregators.AggregationContext,NRules.RuleModel.ITuple,System.Collections.Generic.IEnumerable{NRules.RuleModel.IFact})">
            <summary>
            Called by the rules engine when existing facts are removed from the corresponding aggregator.
            </summary>
            <param name="context">Aggregation context.</param>
            <param name="tuple">Tuple containing preceding partial matches.</param>
            <param name="facts">Existing facts to remove from the aggregate.</param>
            <returns>Results of the operation on the aggregate, based on the removed facts.</returns>
        </member>
        <member name="T:NRules.Aggregators.IAggregatorFactory">
            <summary>
            Base interface for aggregator factories.
            Aggregator factory constructs new instances of <see cref="T:NRules.Aggregators.IAggregator"/> of a given type, so that they
            can accumulate aggregation results.
            An <c>IAggregatorFactory</c> type must either be registered in <see cref="P:NRules.RuleCompiler.AggregatorRegistry"/>,
            or provided in the canonical rule model via <see cref="P:NRules.RuleModel.AggregateElement.CustomFactoryType"/>. If both are
            provided, the aggregator factory at the <see cref="T:NRules.RuleModel.AggregateElement"/> level takes precedence.
            </summary>
        </member>
        <member name="M:NRules.Aggregators.IAggregatorFactory.Compile(NRules.RuleModel.AggregateElement,System.Collections.Generic.IEnumerable{NRules.Aggregators.IAggregateExpression})">
            <summary>
            Called by the rules engine to compile the aggregator factory before it is used for the first time.
            </summary>
            <param name="element">Corresponding aggregate element from the rule definition.</param>
            <param name="compiledExpressions">Aggregate expressions compiled to an executable form.</param>
        </member>
        <member name="M:NRules.Aggregators.IAggregatorFactory.Create">
            <summary>
            Creates a new aggregator instance.
            This method is called by the engine for each new combination of preceding partial matches, 
            so that a new instance of the aggregator is created to accummulate the results.
            </summary>
            <returns>Aggregator instance.</returns>
        </member>
        <member name="T:NRules.Aggregators.MultiKeySortedAggregator`1">
            <summary>
            Aggregate that adds matching facts into a collection sorted by a given key selector and sort direction.
            </summary>
            <typeparam name="TSource">Type of elements to collect.</typeparam>
        </member>
        <member name="T:NRules.Aggregators.ProjectionAggregator`2">
            <summary>
            Aggregator that projects matching facts into new elements.
            </summary>
            <typeparam name="TSource">Type of source element.</typeparam>
            <typeparam name="TResult">Type of result element.</typeparam>
        </member>
        <member name="T:NRules.Aggregators.ProjectionAggregatorFactory">
            <summary>
            Aggregator factory for projection aggregator.
            </summary>
        </member>
        <member name="T:NRules.Aggregators.SortedAggregator`2">
            <summary>
            Aggregate that adds matching facts into a collection sorted by a given key selector and sort direction.
            </summary>
            <typeparam name="TSource">Type of source element.</typeparam>
            <typeparam name="TKey">Type of key used in the key selector for sorting.</typeparam>
        </member>
        <member name="T:NRules.Diagnostics.AgendaEventArgs">
            <summary>
            Information related to agenda events.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.AgendaEventArgs.#ctor(NRules.RuleModel.IMatch)">
            <summary>
            Initializes a new instance of the <c>AgendaEventArgs</c> class.
            </summary>
            <param name="match">Rule match related to the event.</param>
        </member>
        <member name="P:NRules.Diagnostics.AgendaEventArgs.Rule">
            <summary>
            Rule related to the event.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.AgendaEventArgs.Facts">
            <summary>
            Facts related to the event.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.AgendaExpressionErrorEventArgs">
            <summary>
            Information related to error events raised during agenda expression evaluation.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.AgendaExpressionErrorEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object[],NRules.RuleModel.IMatch)">
            <summary>
            Initializes a new instance of the <c>AgendaExpressionErrorEventArgs</c> class.
            </summary>
            <param name="expression">Expression related to the event.</param>
            <param name="exception">Exception related to the event.</param>
            <param name="arguments">Expression arguments.</param>
            <param name="match">Rule match related to the event.</param>
        </member>
        <member name="P:NRules.Diagnostics.AgendaExpressionErrorEventArgs.IsHandled">
            <inheritdoc />
        </member>
        <member name="T:NRules.Diagnostics.AgendaExpressionEventArgs">
            <summary>
            Information related to events raised during agenda expression evaluation.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.AgendaExpressionEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object[],System.Object,NRules.RuleModel.IMatch)">
            <summary>
            Initializes a new instance of the <c>AgendaExpressionEventArgs</c> class.
            </summary>
            <param name="expression">Expression related to the event.</param>
            <param name="exception">Exception related to the event.</param>
            <param name="arguments">Expression arguments.</param>
            <param name="result">Expression result.</param>
            <param name="match">Rule match related to the event.</param>
        </member>
        <member name="P:NRules.Diagnostics.AgendaExpressionEventArgs.Rule">
            <summary>
            Rule related to the event.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.AgendaExpressionEventArgs.Facts">
            <summary>
            Facts related to the event.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.IEventProvider">
            <summary>
            Provider of rules session events.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.ActivationCreatedEvent">
            <summary>
            Raised when a new rule activation is created.
            A new activation is created when a new set of facts (tuple) matches a rule.
            The activation is placed on the agenda and becomes a candidate for firing.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.ActivationUpdatedEvent">
            <summary>
            Raised when an existing activation is updated.
            An activation is updated when a previously matching set of facts (tuple) is updated 
            and it still matches the rule.
            The activation is updated in the agenda and remains a candidate for firing.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.ActivationDeletedEvent">
            <summary>
            Raised when an existing activation is deleted.
            An activation is deleted when a previously matching set of facts (tuple) no longer 
            matches the rule due to updated or retracted facts.
            The activation is removed from the agenda and is no longer a candidate for firing.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.RuleFiringEvent">
            <summary>
            Raised before a rule is about to fire.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.RuleFiredEvent">
            <summary>
            Raised after a rule has fired and all its actions executed.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.FactInsertingEvent">
            <summary>
            Raised before a new fact is inserted into working memory.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.FactInsertedEvent">
            <summary>
            Raised after a new fact is inserted into working memory.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.FactUpdatingEvent">
            <summary>
            Raised before an existing fact is updated in the working memory.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.FactUpdatedEvent">
            <summary>
            Raised after an existing fact is updated in the working memory.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.FactRetractingEvent">
            <summary>
            Raised before an existing fact is retracted from the working memory.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.FactRetractedEvent">
            <summary>
            Raised after an existing fact is retracted from the working memory.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.LhsExpressionEvaluatedEvent">
            <summary>
            Raised when left-hand side expression is evaluated.
            This event is raised on both, successful expression evaluations, and on exceptions.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.LhsExpressionFailedEvent">
            <summary>
            Raised when left-hand side expression evaluation threw an exception.
            Gives observer of the event control over handling of the exception.
            </summary>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.AgendaExpressionEvaluatedEvent">
            <summary>
            Raised when agenda expression is evaluated.
            This event is raised on both, successful expression evaluations, and on exceptions.
            </summary>
            <seealso cref="T:NRules.AgendaFilters.IAgendaFilter"/>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.AgendaExpressionFailedEvent">
            <summary>
            Raised when agenda expression evaluation threw an exception.
            Gives observer of the event control over handling of the exception.
            </summary>
            <seealso cref="T:NRules.AgendaFilters.IAgendaFilter"/>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.RhsExpressionEvaluatedEvent">
            <summary>
            Raised when right-hand side expression is evaluated.
            This event is raised on both, successful expression evaluations, and on exceptions.
            </summary>
            <seealso cref="T:NRules.Extensibility.IActionInterceptor"/>
        </member>
        <member name="E:NRules.Diagnostics.IEventProvider.RhsExpressionFailedEvent">
            <summary>
            Raised when right-hand side expression evaluation threw an exception.
            Gives observer of the event control over handling of the exception.
            </summary>
            <seealso cref="T:NRules.Extensibility.IActionInterceptor"/>
        </member>
        <member name="T:NRules.Diagnostics.ExpressionEventArgs">
            <summary>
            Information related to expression evaluation events.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.ExpressionEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object,System.Object)">
            <summary>
            Initializes a new instance of the <c>ExpressionEventArgs</c> class.
            </summary>
            <param name="expression">Expression that caused the event.</param>
            <param name="exception">Exception thrown during expression evaluation.</param>
            <param name="argument">Argument passed to expression during evaluation.</param>
            <param name="result">Result of expression evaluation.</param>
        </member>
        <member name="M:NRules.Diagnostics.ExpressionEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object[],System.Object)">
            <summary>
            Initializes a new instance of the <c>ExpressionEventArgs</c> class.
            </summary>
            <param name="expression">Expression that caused the event.</param>
            <param name="exception">Exception thrown during expression evaluation.</param>
            <param name="arguments">Arguments passed to expression during evaluation.</param>
            <param name="result">Result of expression evaluation.</param>
        </member>
        <member name="P:NRules.Diagnostics.ExpressionEventArgs.Expression">
            <summary>
            Expression that caused the event;
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.ExpressionEventArgs.Exception">
            <summary>
            Exception thrown during expression evaluation.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.ExpressionEventArgs.Arguments">
            <summary>
            Arguments passed to the expression during evaluation.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.ExpressionEventArgs.Result">
            <summary>
            Result of expression evaluation.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.IRecoverableError">
            <summary>
            Error event that can be handled by the consumer.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.IRecoverableError.IsHandled">
            <summary>
            Flag that indicates whether the exception was handled.
            If handler sets this to <c>true</c> then engine continues execution,
            otherwise exception is rethrown and terminates engine's execution.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.IRecoverableError.Exception">
            <summary>
            Exception that caused the error.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.ISessionSnapshotProvider">
            <summary>
            Provides a snapshot of rules session state.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.ISessionSnapshotProvider.GetSnapshot">
            <summary>
            Returns a snapshot of session state for diagnostics.
            Session state is a graph representing the structure of the underlying Rete network and location of facts in memory nodes.
            </summary>
            <returns>Session snapshot.</returns>
        </member>
        <member name="T:NRules.Diagnostics.LhsExpressionErrorEventArgs">
            <summary>
            Information related to error events raised during left-hand side expression evaluation.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.LhsExpressionErrorEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object[],NRules.RuleModel.ITuple,NRules.RuleModel.IFact,System.Collections.Generic.IEnumerable{NRules.RuleModel.IRuleDefinition})">
            <summary>
            Initializes a new instance of the <c>LhsExpressionErrorEventArgs</c> class.
            </summary>
            <param name="expression">Expression related to the event.</param>
            <param name="exception">Exception related to the event.</param>
            <param name="arguments">Expression arguments.</param>
            <param name="tuple">Tuple related to the event.</param>
            <param name="fact">Fact related to the event.</param>
            <param name="rules">Rules that contain the expression that generated the event.</param>
        </member>
        <member name="M:NRules.Diagnostics.LhsExpressionErrorEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object,NRules.RuleModel.ITuple,NRules.RuleModel.IFact,System.Collections.Generic.IEnumerable{NRules.RuleModel.IRuleDefinition})">
            <summary>
            Initializes a new instance of the <c>LhsExpressionErrorEventArgs</c> class.
            </summary>
            <param name="expression">Expression related to the event.</param>
            <param name="exception">Exception related to the event.</param>
            <param name="argument">Expression argument.</param>
            <param name="tuple">Tuple related to the event.</param>
            <param name="fact">Fact related to the event.</param>
            <param name="rules">Rules that contain the expression that generated the event.</param>
        </member>
        <member name="P:NRules.Diagnostics.LhsExpressionErrorEventArgs.IsHandled">
            <inheritdoc />
        </member>
        <member name="T:NRules.Diagnostics.LhsExpressionEventArgs">
            <summary>
            Information related to events raised during left-hand side expression evaluation.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.LhsExpressionEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object[],System.Object,NRules.RuleModel.ITuple,NRules.RuleModel.IFact,System.Collections.Generic.IEnumerable{NRules.RuleModel.IRuleDefinition})">
            <summary>
            Initializes a new instance of the <c>LhsExpressionEventArgs</c> class.
            </summary>
            <param name="expression">Expression related to the event.</param>
            <param name="exception">Exception related to the event.</param>
            <param name="arguments">Expression arguments.</param>
            <param name="result">Expression result.</param>
            <param name="tuple">Tuple related to the event.</param>
            <param name="fact">Fact related to the event.</param>
            <param name="rules">Rules that contain the expression that generated the event.</param>
        </member>
        <member name="M:NRules.Diagnostics.LhsExpressionEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object,System.Object,NRules.RuleModel.ITuple,NRules.RuleModel.IFact,System.Collections.Generic.IEnumerable{NRules.RuleModel.IRuleDefinition})">
            <summary>
            Initializes a new instance of the <c>LhsExpressionEventArgs</c> class.
            </summary>
            <param name="expression">Expression related to the event.</param>
            <param name="exception">Exception related to the event.</param>
            <param name="argument">Expression argument.</param>
            <param name="result">Expression result.</param>
            <param name="tuple">Tuple related to the event.</param>
            <param name="fact">Fact related to the event.</param>
            <param name="rules">Rules that contain the expression that generated the event.</param>
        </member>
        <member name="P:NRules.Diagnostics.LhsExpressionEventArgs.Facts">
            <summary>
            Facts related to the event.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.LhsExpressionEventArgs.Rules">
            <summary>
            Rules that contain the expression that generated the event.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.LinkInfo">
            <summary>
            Link between nodes in the rete network graph.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.LinkInfo.Source">
            <summary>
            Source node.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.LinkInfo.Target">
            <summary>
            Target node.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.NodeType">
            <summary>
            Types of nodes in the rete network.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.NodeInfo">
            <summary>
            Node in the rete network graph.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.NodeInfo.NodeType">
            <summary>
            Type of the node in the rete network.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.NodeInfo.Details">
            <summary>
            Additional node details.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.NodeInfo.Conditions">
            <summary>
            Match conditions.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.NodeInfo.Expressions">
            <summary>
            Additional node expressions.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.NodeInfo.Items">
            <summary>
            Facts/tuples currently associated with the node.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.RhsExpressionErrorEventArgs">
            <summary>
            Information related to error events raised during right-hand side expression evaluation.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.RhsExpressionErrorEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object[],NRules.RuleModel.IMatch)">
            <summary>
            Initializes a new instance of the <c>RhsExpressionErrorEventArgs</c> class.
            </summary>
            <param name="expression">Expression related to the event.</param>
            <param name="exception">Exception related to the event.</param>
            <param name="arguments">Expression arguments.</param>
            <param name="match">Rule match related to the event.</param>
        </member>
        <member name="P:NRules.Diagnostics.RhsExpressionErrorEventArgs.IsHandled">
            <inheritdoc />
        </member>
        <member name="T:NRules.Diagnostics.RhsExpressionEventArgs">
            <summary>
            Information related to events raised during right-hand side expression evaluation.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.RhsExpressionEventArgs.#ctor(System.Linq.Expressions.Expression,System.Exception,System.Object[],NRules.RuleModel.IMatch)">
            <summary>
            Initializes a new instance of the <c>RhsExpressionEventArgs</c> class.
            </summary>
            <param name="expression">Expression related to the event.</param>
            <param name="exception">Exception related to the event.</param>
            <param name="arguments">Expression arguments.</param>
            <param name="match">Rule match related to the event.</param>
        </member>
        <member name="P:NRules.Diagnostics.RhsExpressionEventArgs.Match">
            <summary>
            Rule match related to the event.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.SessionSnapshot">
            <summary>
            Snapshot of rules session state.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.SessionSnapshot.Nodes">
            <summary>
            Nodes of the rete network graph.
            </summary>
        </member>
        <member name="P:NRules.Diagnostics.SessionSnapshot.Links">
            <summary>
            Links between nodes of the rete network graph.
            </summary>
        </member>
        <member name="T:NRules.Diagnostics.WorkingMemoryEventArgs">
            <summary>
            Information related to working memory events.
            </summary>
        </member>
        <member name="M:NRules.Diagnostics.WorkingMemoryEventArgs.#ctor(NRules.RuleModel.IFact)">
            <summary>
            Initializes a new instance of the <c>WorkingMemoryEventArgs</c> class.
            </summary>
            <param name="fact">Fact related to the event.</param>
        </member>
        <member name="P:NRules.Diagnostics.WorkingMemoryEventArgs.Fact">
            <summary>
            Fact related to the event.
            </summary>
        </member>
        <member name="T:NRules.ExpressionEvaluationException">
            <summary>
            Exception raised if evaluation of the expression failed.
            Inner exception contains the details of the failure.
            </summary>
        </member>
        <member name="P:NRules.ExpressionEvaluationException.Expression">
            <summary>
            Expression that failed to evaluate.
            </summary>
        </member>
        <member name="P:NRules.ExpressionEvaluationException.IsHandled">
            <summary>
            Indicates whether exception was handled via event handler.
            </summary>
        </member>
        <member name="T:NRules.Extensibility.IDependencyResolver">
            <summary>
            Defines a mechanism to resolve rule dependencies at runtime.
            An instance of <c>IDependencyResolver</c> can be assigned to <see cref="P:NRules.ISessionFactory.DependencyResolver"/> or
            <see cref="P:NRules.ISession.DependencyResolver"/>, so that all requests for rule dependencies resolution are fulfiled by that resolver.
            </summary>
            <remarks>If dependency resolver is not configured, any attempt to resolve rule dependencies will result in exception.</remarks>
        </member>
        <member name="M:NRules.Extensibility.IDependencyResolver.Resolve(NRules.Extensibility.IResolutionContext,System.Type)">
            <summary>
            Resolves a registered service (normally via an IoC container).
            </summary>
            <param name="context">Information about the context at which the resolution call is made.</param>
            <param name="serviceType">The type of requested service.</param>
            <returns>Requested service.</returns>
        </member>
        <member name="T:NRules.Extensibility.IActionInterceptor">
            <summary>
            Extension point for rule actions interception.
            An instance of <c>IActionInterceptor</c> can be assigned to <see cref="P:NRules.ISessionFactory.ActionInterceptor"/> or
            <see cref="P:NRules.ISession.ActionInterceptor"/>, so that invocation of all rule actions is delegated to the interceptor.
            The interceptor is free to add pre- or post-processing to action invocations, error handling, or decide not to invoke
            the actions.
            </summary>
            <remarks>
            When actions are invoked via <c>IActionInterceptor</c>, exceptions thrown by actions
            are not wrapped into <see cref="T:NRules.RuleRhsExpressionEvaluationException"/>. It is the responsibility
            of the interceptor to handle the exceptions.
            Exceptions thrown from the interceptor are not handled by the engine and just propagate up the stack.
            </remarks>
        </member>
        <member name="M:NRules.Extensibility.IActionInterceptor.Intercept(NRules.RuleModel.IContext,System.Collections.Generic.IEnumerable{NRules.Extensibility.IActionInvocation})">
            <summary>
            Called by the rules engine in place of the action invocations when a rule fires.
            The interceptor can add behavior to action invocation and choose to either proceed with the invocations or not.
            </summary>
            <param name="context">Action context, containing information about the firing rule and matched facts.</param>
            <param name="actions">Action invocations for rule actions being intercepted.</param>
        </member>
        <member name="T:NRules.Extensibility.IActionInvocation">
            <summary>
            Represents invocation of the proxied rule action.
            </summary>
        </member>
        <member name="P:NRules.Extensibility.IActionInvocation.Arguments">
            <summary>
            Action arguments.
            To get more information about the matched facts, whether they are passed to a given action or not,
            use <see cref="T:NRules.RuleModel.IContext"/> passed to the <see cref="M:NRules.Extensibility.IActionInterceptor.Intercept(NRules.RuleModel.IContext,System.Collections.Generic.IEnumerable{NRules.Extensibility.IActionInvocation})"/> method.
            </summary>
            <remarks>Action arguments also include dependencies that are passed to the action method.</remarks>
            <remarks>Action arguments don't include <c>IContext</c>.</remarks>
        </member>
        <member name="M:NRules.Extensibility.IActionInvocation.Invoke">
            <summary>
            Invokes the action.
            </summary>
        </member>
        <member name="P:NRules.Extensibility.IActionInvocation.Trigger">
            <summary>
            Activation events that trigger this action.
            </summary>
        </member>
        <member name="T:NRules.Extensibility.IResolutionContext">
            <summary>
            Context for dependency resolution.
            </summary>
        </member>
        <member name="P:NRules.Extensibility.IResolutionContext.Session">
            <summary>
            Rules engine session that requested dependency resolution.
            </summary>
        </member>
        <member name="P:NRules.Extensibility.IResolutionContext.Rule">
            <summary>
            Rule that requested dependency resolution.
            </summary>
        </member>
        <member name="T:NRules.IFactResult">
            <summary>
            Result of an operation on a set of facts.
            </summary>
        </member>
        <member name="P:NRules.IFactResult.FailedCount">
            <summary>
            Number of facts on which the operation failed.
            </summary>
        </member>
        <member name="P:NRules.IFactResult.Failed">
            <summary>
            Facts on which the operation failed.
            </summary>
        </member>
        <member name="T:NRules.ILinkedFactSource">
            <summary>
            Fact source for linked facts.
            </summary>
        </member>
        <member name="P:NRules.ILinkedFactSource.Rule">
            <summary>
            Rule that generated the linked fact.
            </summary>
        </member>
        <member name="P:NRules.Rete.Tuple.Facts">
            <summary>
            Facts contained in the tuple in reverse order (fast iteration over linked list).
            Reverse collection to get facts in their actual order.
            </summary>
        </member>
        <member name="M:NRules.Rete.TupleExtensions.OrderedFacts(NRules.RuleModel.ITuple)">
            <summary>
            Facts contained in the tuple in correct order.
            </summary>
            <remarks>This method has to reverse the linked list and is slow.</remarks>
        </member>
        <member name="T:NRules.RuleCompilationException">
            <summary>
            Represents errors that occur while compiling a rule.
            </summary>
        </member>
        <member name="P:NRules.RuleCompilationException.RuleName">
            <summary>
            Rule that caused exception.
            </summary>
        </member>
        <member name="T:NRules.RuleCompiler">
            <summary>
            Compiles rules in a canonical rule model form into an executable representation.
            </summary>
        </member>
        <member name="P:NRules.RuleCompiler.AggregatorRegistry">
            <summary>
            Registry of custom aggregator factories.
            </summary>
        </member>
        <member name="M:NRules.RuleCompiler.Compile(System.Collections.Generic.IEnumerable{NRules.RuleModel.IRuleDefinition})">
            <summary>
            Compiles a collection of rules into a session factory.
            </summary>
            <param name="ruleDefinitions">Rules to compile.</param>
            <returns>Session factory.</returns>
            <exception cref="T:NRules.RuleCompilationException">Any fatal error during rules compilation.</exception>
            <seealso cref="T:NRules.RuleModel.IRuleRepository"/>
        </member>
        <member name="M:NRules.RuleCompiler.Compile(System.Collections.Generic.IEnumerable{NRules.RuleModel.IRuleSet})">
            <summary>
            Compiles rules from rule sets into a session factory.
            </summary>
            <param name="ruleSets">Rule sets to compile.</param>
            <returns>Session factory.</returns>
        </member>
        <member name="T:NRules.RuleExecutionException">
            <summary>
            Represents errors that occur during rules execution.
            </summary>
        </member>
        <member name="T:NRules.RuleExpressionEvaluationException">
            <summary>
            Represents errors that occur while evaluating expressions as part of rules execution.
            </summary>
        </member>
        <member name="P:NRules.RuleExpressionEvaluationException.Expression">
            <summary>
            Expression that caused exception.
            </summary>
        </member>
        <member name="T:NRules.RuleLhsExpressionEvaluationException">
            <summary>
            Represents errors that occur while evaluating rule left-hand side expression.
            </summary>
        </member>
        <member name="M:NRules.RuleRepositoryExtensions.GetRules(NRules.RuleModel.IRuleRepository)">
            <summary>
            Retrieves all rules from all rule sets contained in the repository.
            </summary>
            <returns>Collection of rules from the repository.</returns>
        </member>
        <member name="M:NRules.RuleRepositoryExtensions.Compile(NRules.RuleModel.IRuleRepository)">
            <summary>
            Compiles all rules in the repository into a session factory.
            Use <see cref="T:NRules.RuleCompiler"/> explicitly if only need to compile a subset of rules.
            </summary>
            <param name="repository">Rule repository.</param>
            <returns>Session factory.</returns>
            <seealso cref="T:NRules.RuleCompiler"/>
        </member>
        <member name="T:NRules.RuleRhsExpressionEvaluationException">
            <summary>
            Represents errors that occur while evaluating rule right-hand side expresson.
            </summary>
        </member>
        <member name="P:NRules.RuleRhsExpressionEvaluationException.RuleName">
            <summary>
            Rule that caused exception.
            </summary>
        </member>
        <member name="T:NRules.ISession">
            <summary>
            Represents a rules engine session. Created by <see cref="T:NRules.ISessionFactory"/>.
            Each session has its own working memory, and exposes operations that 
            manipulate facts in it, as well as fire matching rules.
            </summary>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactInsertingEvent">Before processing fact insertion.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactInsertedEvent">After processing fact insertion.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactUpdatingEvent">Before processing fact update.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactUpdatedEvent">After processing fact update.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactRetractingEvent">Before processing fact retraction.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactRetractedEvent">After processing fact retraction.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.ActivationCreatedEvent">When a set of facts matches a rule.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.ActivationUpdatedEvent">When a set of facts is updated and re-matches a rule.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.ActivationDeletedEvent">When a set of facts no longer matches a rule.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.RuleFiringEvent">Before rule's actions are executed.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.RuleFiredEvent">After rule's actions are executed.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.LhsExpressionEvaluatedEvent">When an left-hand side expression was evaluated.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.LhsExpressionFailedEvent">When there is an error during left-hand side expression evaluation,
            before throwing exception to the client.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.AgendaExpressionEvaluatedEvent">When an agenda expression was evaluated.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.AgendaExpressionFailedEvent">When there is an error during agenda expression evaluation,
            before throwing exception to the client.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.RhsExpressionEvaluatedEvent">When an right-hand side expression was evaluated.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.RhsExpressionFailedEvent">When there is an error during right-hand side expression evaluation,
            before throwing exception to the client.</event>
            <exception cref="T:NRules.RuleLhsExpressionEvaluationException">Error while evaluating any of the rules' left-hand side expressons.
            This exception can also be observed as an event <see cref="E:NRules.Diagnostics.IEventProvider.LhsExpressionEvaluatedEvent"/>.</exception>
            <exception cref="T:NRules.AgendaExpressionEvaluationException">Error while evaluating any of the agenda expressions.
            This exception can also be observed as an event <see cref="E:NRules.Diagnostics.IEventProvider.AgendaExpressionFailedEvent"/>.</exception>
            <exception cref="T:NRules.RuleRhsExpressionEvaluationException">Error while evaluating any of the rules' right-hand side expressions.
            This exception can also be observed as an event <see cref="E:NRules.Diagnostics.IEventProvider.RhsExpressionFailedEvent"/>.</exception>
            <seealso cref="T:NRules.ISessionFactory"/>
            <threadsafety instance="false" />
        </member>
        <member name="P:NRules.ISession.Agenda">
            <summary>
            Agenda, which represents a store for rule matches.
            </summary>
        </member>
        <member name="P:NRules.ISession.Events">
            <summary>
            Provider of events from the current rule session.
            Use it to subscribe to various rules engine lifecycle events.
            </summary>
        </member>
        <member name="P:NRules.ISession.DependencyResolver">
            <summary>
            Rules dependency resolver for the current rules session.
            </summary>
        </member>
        <member name="P:NRules.ISession.ActionInterceptor">
            <summary>
            Action interceptor for the current rules session.
            If provided, invocation of rule actions is delegated to the interceptor.
            </summary>
        </member>
        <member name="M:NRules.ISession.InsertAll(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Inserts new facts to the rules engine memory.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="facts">Facts to insert.</param>
            <exception cref="T:System.ArgumentException">If any fact already exists in working memory.</exception>
        </member>
        <member name="M:NRules.ISession.TryInsertAll(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Inserts new facts to the rules engine memory if the facts don't exist.
            If any of the facts exists in the engine, none of the facts are inserted.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="facts">Facts to insert.</param>
            <returns>Result of facts insertion.</returns>
        </member>
        <member name="M:NRules.ISession.Insert(System.Object)">
            <summary>
            Inserts new fact to the rules engine memory.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="fact">Facts to insert.</param>
            <exception cref="T:System.ArgumentException">If fact already exists in working memory.</exception>
        </member>
        <member name="M:NRules.ISession.TryInsert(System.Object)">
            <summary>
            Inserts a fact to the rules engine memory if the fact does not exist.
            </summary>
            <param name="fact">Fact to insert.</param>
            <returns>Whether the fact was inserted or not.</returns>
        </member>
        <member name="M:NRules.ISession.UpdateAll(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Updates existing facts in the rules engine memory.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="facts">Facts to update.</param>
            <exception cref="T:System.ArgumentException">If any fact does not exist in working memory.</exception>
        </member>
        <member name="M:NRules.ISession.TryUpdateAll(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Updates existing facts in the rules engine memory if the facts exist.
            If any of the facts don't exist in the engine, none of the facts are updated.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="facts">Facts to update.</param>
            <returns>Result of facts update.</returns>
        </member>
        <member name="M:NRules.ISession.Update(System.Object)">
            <summary>
            Updates existing fact in the rules engine memory.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="fact">Fact to update.</param>
            <exception cref="T:System.ArgumentException">If fact does not exist in working memory.</exception>
        </member>
        <member name="M:NRules.ISession.TryUpdate(System.Object)">
            <summary>
            Updates a fact in the rules engine memory if the fact exists.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="fact">Fact to update.</param>
            <returns>Whether the fact was updated or not.</returns>
        </member>
        <member name="M:NRules.ISession.RetractAll(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Removes existing facts from the rules engine memory.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="facts">Facts to remove.</param>
            <exception cref="T:System.ArgumentException">If any fact does not exist in working memory.</exception>
        </member>
        <member name="M:NRules.ISession.TryRetractAll(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Removes existing facts from the rules engine memory if the facts exist.
            If any of the facts don't exist in the engine, none of the facts are removed.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="facts">Facts to remove.</param>
            <returns>Result of facts removal.</returns>
        </member>
        <member name="M:NRules.ISession.Retract(System.Object)">
            <summary>
            Removes existing fact from the rules engine memory.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="fact">Fact to remove.</param>
            <exception cref="T:System.ArgumentException">If fact does not exist in working memory.</exception>
        </member>
        <member name="M:NRules.ISession.TryRetract(System.Object)">
            <summary>
            Removes a fact from the rules engine memory if the fact exists.
            </summary>
            <remarks>Bulk session operations are more performant than individual operations on a set of facts.</remarks>
            <param name="facts">Fact to remove.</param>
            <returns>Whether the fact was retracted or not.</returns>
        </member>
        <member name="M:NRules.ISession.Fire">
            <summary>
            Starts rules execution cycle.
            This method blocks until there are no more rules to fire.
            </summary>
            <returns>Number of rules that fired.</returns>
        </member>
        <member name="M:NRules.ISession.Fire(System.Int32)">
            <summary>
            Starts rules execution cycle.
            This method blocks until maximum number of rules fired or there are no more rules to fire.
            </summary>
            <param name="maxRulesNumber">Maximum number of rules to fire.</param>
            <returns>Number of rules that fired.</returns>
        </member>
        <member name="M:NRules.ISession.Query``1">
            <summary>
            Creates a LINQ query to retrieve facts of a given type from the rules engine's memory.
            </summary>
            <typeparam name="TFact">Type of facts to query. Use <see cref="T:System.Object"/> to query all facts.</typeparam>
            <returns>Queryable working memory of the rules engine.</returns>
        </member>
        <member name="T:NRules.Session">
            <summary>
            See <see cref="T:NRules.ISession"/>.
            </summary>
        </member>
        <member name="T:NRules.ISessionFactory">
            <summary>
            Represents compiled production rules that can be used to create rules sessions.
            Created by <see cref="T:NRules.RuleCompiler"/> by compiling rule model into an executable form.
            </summary>
            <remarks>
            Session factory is expensive to create (because rules need to be compiled into an executable form).
            Therefore there needs to be only a single instance of session factory for a given set of rules for the lifetime of the application.
            If repeatedly running rules for different sets of facts, don't create a new session factory for each rules run.
            Instead, have a single session factory and create a new rules session for each independent universe of facts.
            </remarks>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactInsertingEvent">Before processing fact insertion.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactInsertedEvent">After processing fact insertion.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactUpdatingEvent">Before processing fact update.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactUpdatedEvent">After processing fact update.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactRetractingEvent">Before processing fact retraction.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.FactRetractedEvent">After processing fact retraction.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.ActivationCreatedEvent">When a set of facts matches a rule.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.ActivationUpdatedEvent">When a set of facts is updated and re-matches a rule.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.ActivationDeletedEvent">When a set of facts no longer matches a rule.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.RuleFiringEvent">Before rule's actions are executed.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.RuleFiredEvent">After rule's actions are executed.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.LhsExpressionEvaluatedEvent">When an left-hand side expression was evaluated.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.LhsExpressionFailedEvent">When there is an error during left-hand side expression evaluation,
            before throwing exception to the client.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.AgendaExpressionEvaluatedEvent">When an agenda expression was evaluated.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.AgendaExpressionFailedEvent">When there is an error during agenda expression evaluation,
            before throwing exception to the client.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.RhsExpressionEvaluatedEvent">When an right-hand side expression was evaluated.</event>
            <event cref="E:NRules.Diagnostics.IEventProvider.RhsExpressionFailedEvent">When there is an error during right-hand side expression evaluation,
            before throwing exception to the client.</event>
            <seealso cref="T:NRules.ISession"/>
            <seealso cref="T:NRules.RuleCompiler"/>
            <threadsafety instance="true" />
        </member>
        <member name="P:NRules.ISessionFactory.Events">
            <summary>
            Provider of events aggregated across all rule sessions. 
            Event sender is used to convey the session instance responsible for the event.
            Use it to subscribe to various rules engine lifecycle events.
            </summary>
        </member>
        <member name="P:NRules.ISessionFactory.DependencyResolver">
            <summary>
            Rules dependency resolver for all rules sessions.
            </summary>
        </member>
        <member name="P:NRules.ISessionFactory.ActionInterceptor">
            <summary>
            Action interceptor for all rules sessions.
            If provided, invocation of rule actions is delegated to the interceptor.
            </summary>
        </member>
        <member name="M:NRules.ISessionFactory.CreateSession">
            <summary>
            Creates a new rules session.
            </summary>
            <returns>New rules session.</returns>
        </member>
        <member name="M:NRules.ISessionFactory.CreateSession(System.Action{NRules.ISession})">
            <summary>
            Creates a new rules session.
            </summary>
            <param name="initializationAction">Action invoked on the newly created session, before the session is activated (which could result in rule matches placed on the agenda).</param>
            <returns>New rules session.</returns>
        </member>
        <member name="M:NRules.Utilities.ExpressionCompiler.ExpressionSingleParameterOptimizer`1.ConvertParameter(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Transforms expression from single typed parameter to single object parameter,
            which allows execution w/o reflection.
            </summary>
            <param name="expression">Expression to transform.</param>
            <returns>Transformed expression.</returns>
        </member>
        <member name="M:NRules.Utilities.ExpressionCompiler.ExpressionMultiParameterOptimizer`1.CompactParameters(System.Linq.Expressions.LambdaExpression,System.Int32)">
            <summary>
            Transforms expression from multi-parameter to single array parameter,
            which allows execution w/o reflection.
            </summary>
            <param name="expression">Expression to transform.</param>
            <param name="startIndex">Index of the first parameter to compact into an array.</param>
            <returns>Transformed expression.</returns>
        </member>
        <member name="M:NRules.Utilities.IndexMapExtensions.ToIndexMap``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts sequence to an index lookup map.
            </summary>
            <typeparam name="TElement">Type of element in the sequence.</typeparam>
            <param name="sequence">Sequence to convert.</param>
            <returns>Index lookup dictionary.</returns>
        </member>
        <member name="M:NRules.Utilities.IndexMapExtensions.IndexOrDefault``1(System.Collections.Generic.Dictionary{``0,System.Int32},``0)">
            <summary>
            Returns element's index or -1.
            </summary>
            <typeparam name="TElement">Type of element in the index map.</typeparam>
            <param name="indexMap">Index map.</param>
            <param name="element">Element to lookup.</param>
            <returns></returns>
        </member>
    </members>
</doc>
